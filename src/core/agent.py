import re
import os
import zipfile
from typing import List, Dict
from src.core.interfaces import (
    IEmailProvider, ILLMProvider, IInvoiceRepository, 
    IAttachmentProcessor, IVectorStore
)
from src.core.logic import ReconciliationService
from src.models import InvoiceStatus, ExtractedInvoiceData

class InvoiceAgent:
    def __init__(
        self,
        email_provider: IEmailProvider,
        llm_provider: ILLMProvider,
        db: IInvoiceRepository,
        vector_store: IVectorStore,
        attachment_processor: IAttachmentProcessor
    ):
        self.email = email_provider
        self.llm = llm_provider
        self.db = db
        self.vector_store = vector_store
        self.processor = attachment_processor

    def _extract_email_address(self, sender_string: str) -> str:
        """Helper to extract 'email@domain.com' from 'Name <email@domain.com>'"""
        if "<" in sender_string and ">" in sender_string:
            return sender_string.split("<")[1].split(">")[0]
        return sender_string.strip()

    def _format_amount(self, amount: any) -> str:
        """Helper to safely format amount as currency."""
        try:
            if amount is None:
                return "N/A"
            val = float(amount)
            return f"${val:,.2f}"
        except (ValueError, TypeError):
            return str(amount)

    def start_reconciliation_flow(self, vendor_email: str) -> str:
        # 1. Get Pending Invoices
        pending_invoices = self.db.get_pending_invoices_by_sender(vendor_email)
        
        if not pending_invoices:
            return "No pending invoices found for this email."

        # 2. Build the HTML Table Rows
        table_rows = ""
        for inv in pending_invoices:
            formatted_amount = self._format_amount(inv.amount)
            table_rows += f"""
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">{inv.workspace}</td>
                <td style="border: 1px solid #ddd; padding: 8px;">{inv.hotel_name}</td>
                <td style="border: 1px solid #ddd; padding: 8px;">{inv.gstin}</td>
                <td style="border: 1px solid #ddd; padding: 8px;"><b>{inv.invoice_number}</b></td>
                <td style="border: 1px solid #ddd; padding: 8px;">{formatted_amount}</td>
            </tr>
            """

        # 3. Construct the Full HTML Body
        html_body = f"""
        <html>
        <body>
            <p>Dear Hotel Team,</p>
            <p><b>Requesting copies of Hotel Stay Invoices issued for the stays mentioned below ‚Äì your assistance is appreciated.</b></p>
            <p>As part of our compliance and reconciliation process, we are reaching out to request <b>soft copies of Tax Invoices</b> that were generated by your property.</p>
            <h3>List of Invoices</h3>
            <p>We have identified the following invoices issued by your property. Please refer to the table below:</p>
            <table style="border-collapse: collapse; width: 100%; font-family: Arial, sans-serif; font-size: 11px;">
                <thead>
                    <tr style="background-color: #f2f2f2;">
                        <th style="border: 1px solid #ddd; padding: 8px;">Workspace</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">Hotel Name</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">Hotel GSTIN</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">Invoice Number</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">Amount</th>
                    </tr>
                </thead>
                <tbody>{table_rows}</tbody>
            </table>
            <br><p>Warm Regards,<br><b>Operation Team</b><br><span style="color: blue;">Finkraft.ai</span></p>
        </body></html>
        """

        thread_id = self.email.send_new_email(
            to_email=vendor_email,
            subject=f"Action Required: GST Tax Invoices Required | {len(pending_invoices)} Pending",
            body=html_body
        )
        return f"Request sent! Thread ID: {thread_id}"

    def run_daily_reminders(self) -> List[str]:
        reminded_vendors = []
        vendors = self.db.get_vendors_needing_reminders(days_interval=2)
        
        if not vendors:
            return []

        for vendor_email in vendors:
            pending = self.db.get_pending_invoices_by_sender(vendor_email)
            if not pending: continue

            table_rows = ""
            for inv in pending:
                formatted_amount = self._format_amount(inv.amount)
                table_rows += f"<tr><td style='border:1px solid #ddd;padding:8px'>{inv.hotel_name}</td><td style='border:1px solid #ddd;padding:8px'><b>{inv.invoice_number}</b></td><td style='border:1px solid #ddd;padding:8px'>{formatted_amount}</td></tr>"

            html_body = f"""
            <html><body>
            <p>Hello,</p>
            <p>This is a gentle reminder that we are still awaiting the following invoices:</p>
            <table style='border-collapse: collapse; width: 100%;'>{table_rows}</table>
            <p>Please reply with the PDFs attached.</p>
            <p>Best,<br>Finance Team</p>
            </body></html>
            """
            
            self.email.send_new_email(
                to_email=vendor_email,
                subject=f"Reminder: {len(pending)} Outstanding Invoices",
                body=html_body
            )
            self.db.update_reminder_timestamp(vendor_email)
            reminded_vendors.append(vendor_email)
            
        return reminded_vendors

    def run_reconciliation_cycle(self) -> List[Dict]:
        print("\n" + "="*40)
        print("‚ö° STARTING RECONCILIATION CYCLE")
        
        report = []
        emails = self.email.fetch_unread_emails()
        
        print(f"üìß FOUND {len(emails)} UNREAD EMAILS")

        for email in emails:
            print(f"üëâ Processing email from: {email.sender}")
            
            clean_sender = self._extract_email_address(email.sender)
            pending_invoices = self.db.get_pending_invoices_by_sender(clean_sender)
            
            if not pending_invoices:
                print("   ‚ùå No pending invoices found.")
                report.append({
                    "thread_id": email.thread_id, 
                    "sender": email.sender, 
                    "status": f"Log: No pending invoices for {clean_sender}"
                })
                continue

            # --- STEP 1: COLLECT PDF PATHS (Don't process yet) ---
            pdf_queue = []
            has_zip = False
            
            for attachment_path in email.attachments:
                ext = attachment_path.lower()
                
                if ext.endswith(".pdf"):
                    pdf_queue.append(attachment_path)
                
                elif ext.endswith(".zip"):
                    has_zip = True
                    print(f"   üì¶ Unzipping: {attachment_path}")
                    try:
                        extract_path = os.path.dirname(attachment_path)
                        with zipfile.ZipFile(attachment_path, 'r') as zip_ref:
                            zip_ref.extractall(extract_path)
                            for filename in zip_ref.namelist():
                                # Only process PDFs (ignore Mac junk/other files)
                                if filename.lower().endswith(".pdf") and not filename.startswith('__MACOSX'):
                                    full_path = os.path.join(extract_path, filename)
                                    pdf_queue.append(full_path)
                    except Exception as e:
                        print(f"   ‚ùå Error unzipping: {e}")

            # --- STEP 2: TRIAGE (Links / Empty) ---
            body_lower = email.body.lower()
            has_link = "http" in body_lower or "www." in body_lower or "drive.google" in body_lower

            if not pdf_queue and has_link:
                report.append({
                    "thread_id": email.thread_id, "sender": email.sender,
                    "received": [], "missing": [], "draft_reply": "",
                    "status": "üî¥ MANUAL REVIEW: External Link Detected", "poc_update": None
                })
                continue

            if not pdf_queue:
                missing_numbers = [inv.invoice_number for inv in pending_invoices]
                draft = self.llm.draft_reply(
                    sender=email.sender, missing_invoices=missing_numbers, received_invoices=[], 
                    context="The sender replied but forgot to attach files."
                )
                report.append({
                    "thread_id": email.thread_id, "sender": email.sender,
                    "received": [], "missing": missing_numbers, "draft_reply": draft,
                    "status": "Drafting: No Attachments", "poc_update": None
                })
                continue

            # --- STEP 3: PROCESS QUEUE ONE BY ONE ---
            # This Loop ensures the AI looks at every single file individually
            print(f"   üìÑ PDFs to process: {len(pdf_queue)}")
            
            all_found_invoices = []
            poc_change_detected = False
            new_poc_info = None

            for i, pdf_path in enumerate(pdf_queue):
                print(f"      [{i+1}/{len(pdf_queue)}] Converting & Scanning...")
                
                # Convert specific PDF to images
                images = self.processor.convert_pdf_to_images(pdf_path)
                
                if not images: continue

                # Send ONLY this document's images to Gemini
                # This prevents "Lazy AI" issues with large batches
                data = self.llm.extract_invoice_data(email.body, images)
                
                # Accumulate results
                if data.invoice_numbers:
                    print(f"         Found IDs: {data.invoice_numbers}")
                    all_found_invoices.extend(data.invoice_numbers)
                
                if data.detected_poc_change:
                    poc_change_detected = True
                    new_poc_info = data.new_poc_details

            # --- DEBUG OUTPUT ---
            print(f"\n   üîé FINAL MATCH RESULTS:")
            print(f"   ‚û°Ô∏è  DB Expects (Sample): {[i.invoice_number for i in pending_invoices[:3]]}...")
            print(f"   ‚¨ÖÔ∏è  Agent Found Total: {all_found_invoices}")
            print("   ------------------\n")

            # --- RECONCILE ---
            recon_result = ReconciliationService.reconcile(pending_invoices, all_found_invoices)

            for inv in recon_result.updated_invoices:
                # We link the first attachment found as reference for simplicity
                filename = email.attachments[0] if email.attachments else "extracted_from_zip"
                self.db.mark_as_received(inv.invoice_number, filename, email.thread_id)

            draft = self.llm.draft_reply(
                sender=email.sender,
                missing_invoices=recon_result.missing_invoices,
                received_invoices=recon_result.received_invoices,
                context=f"POC Change: {new_poc_info}" if poc_change_detected else ""
            )

            report.append({
                "thread_id": email.thread_id,
                "sender": email.sender,
                "received": recon_result.received_invoices,
                "missing": recon_result.missing_invoices,
                "draft_reply": draft,
                "poc_update": new_poc_info
            })

        print("="*40 + "\n")
        return report

    def send_approved_reply(self, thread_id: str, to_email: str, body: str):
        self.email.send_reply(thread_id, to_email, body)